Ок. Нижче — **один фінальний документ** (без “потім відредагуємо”), на який ти будеш опиратись щодня. Це наш **єдиний план**, і я буду триматись його як рейок: що за чим, де лежить код, які файли, які команди, які “стоп-умови”.

Скопіюй це як файл:

`docs/PLAN_DREAMX_V2.md`

---

# PLAN_DREAMX_V2.md

## DreamX v2.0 — Детальний план розробки (один шлях, без хаосу)

### 0) Мета v2.0

**v2.0** — це стабільна платформа з правильною архітектурою:

* WebApp (UI) + API (backend) + Bots (game/admin/tournaments)
* Єдина DB (Postgres) як джерело правди
* Чіткі потоки: юзер → турніри → матчі → результат → статистика
* Без тимчасових JSON-рішень у “проді”

**Результат v2.0 MVP:**

1. Юзер відкриває WebApp з Telegram → створюється/оновлюється в БД
2. Список турнірів (active/upcoming)
3. Join турніру
4. Waiting room → формування груп → 1 матч (камінь/ножиці/папір)
5. Запис результатів у БД
6. Екран “перемога/поразка” + перехід в меню

> Коментар: ми робимо “мінімум, який працює” і лише потім нарощуємо складність (раунди, сітки, рейтинги, рекламні модулі).

---

## 1) Правила розробки (обов’язково)

### 1.1. “Один крок — один результат”

Працюємо серіями маленьких, завершених кроків:

* кожен крок має **deliverable** (що точно готово)
* кожен крок має **check** (як перевіряємо)

### 1.2. Всі зміни тільки через структуру репозиторію

Ніяких “вкинув файл у корінь бо так швидше”.
Файли завжди в своєму місці.

### 1.3. База — джерело правди

* дані турнірів, участей, матчів — тільки в Postgres
* WebApp показує те, що прийшло з API
* Bots працюють через API/DB модулі

### 1.4. Жорстке правило: не робимо “паралельно 5 речей”

Якщо ми почали “DB + міграції” — ми не стрибаємо в UI/анімації/рекламу.
Спочатку основа.

---

## 2) Структура репозиторію (це “карта світу”)

```
dreamx-v2/
├─ docs/
│  ├─ PLAN_DREAMX_V2.md
│  ├─ DB_SCHEMA.md
│  ├─ API_SPEC.md
│  └─ DEPLOY_RENDER.md
├─ webapp/
│  ├─ index.html
│  ├─ assets/
│  │  ├─ css/
│  │  │  └─ app.css
│  │  └─ js/
│  │     ├─ core.js
│  │     ├─ api.js
│  │     ├─ screens/
│  │     │  ├─ home.js
│  │     │  ├─ tournaments.js
│  │     │  ├─ waiting_room.js
│  │     │  └─ game_rps.js
│  │     └─ ui/
│  │        └─ components.js
├─ backend/
│  ├─ app.py
│  ├─ api/
│  │  ├─ routes_users.py
│  │  ├─ routes_tournaments.py
│  │  └─ routes_games.py
│  ├─ core/
│  │  ├─ auth_telegram.py
│  │  ├─ services_tournaments.py
│  │  └─ services_games.py
│  └─ db/
│     ├─ connection.py
│     ├─ migrate.py
│     └─ schema/
│        ├─ 001_init.sql
│        ├─ 002_tournaments.sql
│        └─ 003_games.sql
└─ bots/
   ├─ shared/
   │  ├─ config.py
   │  └─ api_client.py
   ├─ game_bot/
   │  └─ bot.py
   ├─ admin_bot/
   │  └─ bot.py
   └─ tournaments_bot/
      └─ bot.py
```

> Коментар: якщо у тебе вже є трохи інша структура — ми її НЕ “ламаємо”, але приводимо до цього стандарту поступово. Головне: `webapp/`, `backend/`, `bots/`, `docs/`.

---

## 3) Етапи розробки (рейки) — що за чим

# ЕТАП A — Підготовка “фундамент”

### A1) Створити чистий репозиторій і правила

**Дія:**

* створити `dreamx-v2` repo
* додати структуру папок
* додати `docs/` з цим планом

**Deliverable:** репозиторій з каркасом папок
**Check:** відкривається структура, все на місці

---

### A2) Локальне середовище (мінімальне)

**Дія:**

* `python -m venv .venv`
* `pip install -r backend/requirements.txt`
* підготувати `.env` локально

**Deliverable:** backend запускається локально
**Check:** `/health` повертає `ok`

> Коментар: без цього — далі не йдемо. Це база для швидкої перевірки.

---

# ЕТАП B — База даних і міграції (серце v2)

### B1) Підключення до Postgres (Render) + env

**Дія:**

* отримати `DATABASE_URL` (Render → Postgres → Connect → Internal)
* додати `.env` локально
* додати env у Render services (пізніше, на етапі деплою)

**Deliverable:** локально backend бачить DB
**Check:** простий скрипт робить `SELECT 1`

---

### B2) Міграції: `backend/db/migrate.py`

**Дія:**

* створити `schema/*.sql`
* написати `migrate.py`, який виконує SQL-файли по черзі

**Deliverable:** одна команда створює всі таблиці
**Check:** після запуску міграції таблиці існують

> Коментар: “ручне створення таблиць” заборонене. Тільки міграції.

---

### B3) DB_SCHEMA.md — офіційна схема

**Дія:**

* описати таблиці, ключі, індекси, зв’язки

**Deliverable:** документ `docs/DB_SCHEMA.md`
**Check:** будь-хто може зрозуміти структуру БД

---

# ЕТАП C — API (мінімум, але правильно)

### C1) Telegram Auth (перевірка initData)

**Дія:**

* `backend/core/auth_telegram.py`
* валідація `Telegram WebApp initData`

**Deliverable:** endpoint приймає initData і повертає `user_id`
**Check:** підроблені дані відхиляються, реальні — проходять

> Коментар: якщо поки важко — робимо “dev mode” з прапорцем `APP_ENV=dev`, де дозволено спрощення. Але в коді чітко розділено dev/prod.

---

### C2) Users API

**Ендпоінти:**

* `POST /api/users/upsert` (створити/оновити юзера)
* `GET /api/users/me` (поточний)

**Deliverable:** юзер гарантовано є в БД після входу
**Check:** відкрити WebApp → запис в `users`

---

### C3) Tournaments API

**Ендпоінти:**

* `GET /api/tournaments` (список)
* `POST /api/tournaments/:id/join`
* `GET /api/tournaments/:id` (деталі + статус + лічильники)

**Deliverable:** можна показати список і вступити в турнір
**Check:** `tournament_players` поповнюється

---

### C4) Games API (RPS матч)

**Ендпоінти:**

* `POST /api/games/create` (створити матч у раунді)
* `POST /api/games/:id/move` (хід гравця)
* `GET /api/games/:id/state` (стан гри)

**Deliverable:** матч живе в БД і має результат
**Check:** є записи в `games`, winner_id оновлюється

---

# ЕТАП D — WebApp (екрани строго по черзі)

> Коментар: UI робимо тоді, коли API вже віддає дані.

### D1) core.js + api.js

**Дія:**

* `core.js`: Telegram init, отримання initData, базові утиліти
* `api.js`: fetch wrapper, `API_BASE`, обробка помилок

**Deliverable:** WebApp може робити запити без дублювання коду
**Check:** 1 кнопка робить `/health` і показує “ok”

---

### D2) Home screen

**Дія:**

* екран меню: “Турніри”, “Швидка гра”, “Профіль”

**Deliverable:** стабільний top/bottom layout
**Check:** на різних екранах не ламається скрол

---

### D3) Tournaments screen (список + join)

**Дія:**

* показ карток турнірів
* join → переходить на waiting room

**Deliverable:** повний цикл: список → join
**Check:** join записався в БД, UI показує “ви приєднались”

---

### D4) Waiting room → “формуємо групи”

**Дія:**

* показ лічильника гравців
* статус: waiting / starting / forming_groups

**Deliverable:** екран не зависає, періодично оновлює статус
**Check:** якщо статус став “game_ready” → перейти в game screen

---

### D5) Game RPS screen

**Дія:**

* відобразити “ти vs суперник”
* логіка: вибір камінь/ножиці/папір → результат

**Deliverable:** матч грається і пишеться в БД
**Check:** `games` має winner_id

---

### D6) Result screen

**Дія:**

* перемога/поразка
* кнопки: “Меню”, “Наступний матч” (пізніше)

**Deliverable:** не залипає, повертає в потрібний екран
**Check:** повторний вхід не створює “битих станів”

---

# ЕТАП E — Bots (підключаємо після MVP WebApp)

### E1) Admin bot (створення турніру)

**Дія:**

* діалог створення турніру
* запис у `tournaments`

**Deliverable:** турнір створюється з бота
**Check:** WebApp бачить турнір в списку

---

### E2) Game bot (доступ/меню/лінк на WebApp)

**Дія:**

* `/start` → кнопка “Відкрити DreamX”
* правильний deep-link

**Deliverable:** бот стабільно веде в WebApp
**Check:** юзер створюється/оновлюється при відкритті

---

# ЕТАП F — Deploy на Render (коли локально стабільно)

### F1) backend API deploy

**Дія:**

* Render web service
* env: DATABASE_URL, APP_ENV=prod
* healthcheck

**Deliverable:** API доступне в інтернеті
**Check:** `/health` ok, /api працює

---

### F2) webapp deploy

**Дія:**

* Render static site (webapp/)
* `API_BASE` в конфіг

**Deliverable:** WebApp відкривається по URL
**Check:** з Telegram відкривається і працює

---

### F3) bots deploy

**Дія:**

* 3 services: game/admin/tournaments
* env tokens + DATABASE_URL

**Deliverable:** боти працюють у проді
**Check:** створення турніру → join → гра

---

## 4) “Стоп-умови” (щоб ми не з’їхали)

Ми НЕ переходимо на наступний етап, якщо:

* міграції не відпрацьовують з нуля
* нема `DB_SCHEMA.md`
* API не має мінімальних ендпоінтів для поточного екрана
* WebApp робить логіку “на фронті” замість backend

---

## 5) Як ми працюємо з Codex (щоб ти керував, а не плавав)

### Правило роботи

1. Ти кажеш: **“Йдемо за планом, етап B2”**
2. Я даю тобі:

   * список файлів, які створити/змінити
   * повний код цих файлів
   * куди вставити
   * як запустити/перевірити
3. Ти через Codex застосовуєш зміни
4. Ти скидаєш результат/помилку
5. Йдемо далі тільки після проходження `Check`

---

## 6) Поточний статус (що зроблено / що наступне)

**Зроблено:**

* Postgres створено на Render (`dreamx-v2-postgres`)

**Наступний крок строго за планом:**
➡ **ЕТАП B2: Міграції + schema SQL + migrate.py**
Після цього одразу:
➡ **ЕТАП B3: docs/DB_SCHEMA.md**

---

# Команда “старт” (що ти пишеш мені далі)

Напиши одне речення:
**“Йдемо за планом: етап B2. Дай 001_init.sql + migrate.py + connection.py + requirements.txt (якщо треба)”**

І я дам **готові файли** під твою структуру, щоб ти просто застосував через Codex.

---

Якщо ти готовий — пиши команду “старт” з етапом **B2**. Я не буду стрибати в UI чи турнірні фічі, поки ми не закриємо фундамент.

